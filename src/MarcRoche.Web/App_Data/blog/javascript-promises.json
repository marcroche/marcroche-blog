{"Author":"marcroche","Content":"#JavaScript Promises: Looking at jQuery and Q\r\n\r\n<div>\r\n\t<time class=\"postinfo left-50 postdate\">December 8, 2013</time>\r\n</div>\r\n\r\nPromises provide a method of programming asynchronously in javascript. Prior to promises the most common technique was the use of callbacks. And although callbacks worked fine, they were incredibly tough to follow and difficult to maintain.\r\n\r\nJavaScript promises are formally defined by <a href=\"http://wiki.commonjs.org/wiki/Promises\" target=\"_blank\">CommonJS</a>. There are many implementations that have been developed, but two that you will see most often in both client and server side development are jQuery and Q implementations. *(jQuery on the client and Q in both client and server)*\r\n\r\nLet's create a very basic scenario. \r\n\r\nWe are waiting for a countdown to complete before we can continue further processing. The countdown gives us a 'promise' that it will let us know it is done and then blocks, and when the promise is resolved we can continue processing. <a href='/artifacts/javascript-promises/javascript-promises.html' target=\"_blank\">Click here</a> for a live example.\r\n\r\nThe main application is pretty simple. We create our 'Timer Models' and we wait for processing to occur:\r\n\r\n```JavaScript\r\nvar jQueryTimer = new app_ns.JQueryTimer(),\r\n    qTimer = new app_ns.QTimer(),\r\n    timerDiv = $('#timer'),\r\n    timer2Div = $('#timer2'),\r\n    messageDiv = $('#message');\r\n\r\njQueryTimer.startCountDown(5).progress(function (data) {\r\n    timerDiv.text(data.time);\r\n}).then(function () {\r\n    timerDiv.text('Blast off!');\r\n}).then(function() {\r\n    qTimer.startCountDown(5).progress(function (data) {\r\n        timer2Div.text(data.time);\r\n    }).then(function () {\r\n        timer2Div.text('Blast off!');\r\n    }).then(function() {\r\n        messageDiv.text('Both promises have been resolved.');\r\n    });\r\n});\r\n```\r\n\r\nThe actual configuration of the promise happens in the models. We create the deffered object, return it to the caller, and then resolve it when the promise has been fulfilled. The notify method is only used to send progress updates.\r\n\r\nThe jQuery Model:\r\n\r\n```JavaScript\r\napp_ns.JQueryTimer = (function ($) {\r\n    var self = this;\r\n    var currentTime = 0;\r\n\r\n    var startCountDown = function (initialTime) {\r\n        var deferred = $.Deferred();\r\n        currentTime = initialTime;\r\n\r\n        var counter = setInterval(function () {\r\n            deferred.notify({\r\n                time: currentTime\r\n            });\r\n\r\n            currentTime = currentTime - 1;\r\n\r\n            if (currentTime < 0) {\r\n                clearInterval(counter);\r\n                deferred.resolve();\r\n            }\r\n        }, 1000);\r\n\r\n        return deferred.promise();\r\n    };\r\n  \r\n  var api = function() {\r\n    this.startCountDown = startCountDown;\r\n  };\r\n  \r\n  return api;\r\n})(jQuery);\r\n```\r\n\r\nAnd now the Q model which is identical in all but a couple of minor syntactical nuances:\r\n\r\n```JavaScript\r\napp_ns.QTimer = (function (Q) {\r\n    var self = this;\r\n    var currentTime = 0;\r\n\r\n    var startCountDown = function (initialTime) {\r\n        var deferred = Q.defer();\r\n        currentTime = initialTime;\r\n\r\n        var counter = setInterval(function () {\r\n            deferred.notify({\r\n                time: currentTime\r\n            });\r\n\r\n            currentTime = currentTime - 1;\r\n\r\n            if (currentTime < 0) {\r\n                clearInterval(counter);\r\n                deferred.resolve();\r\n            }\r\n        }, 1000);\r\n\r\n        return deferred.promise;\r\n    };\r\n  \r\n  var api = function() {\r\n    this.startCountDown = startCountDown;\r\n  };\r\n  \r\n  return api;\r\n})(Q);\r\n```\r\n\r\nThat's about it for a basic, raw promise. In coming articles we will examine even more scenarios where promises can make our code cleaner and more concise.","HtmlContent":"<h1>JavaScript Promises: Looking at jQuery and Q</h1>\r\n\r\n<div>\r\n    <time class=\"postinfo left-50 postdate\">December 8, 2013</time>\r\n</div>\r\n\r\n<p>Promises provide a method of programming asynchronously in javascript. Prior to promises the most common technique was the use of callbacks. And although callbacks worked fine, they were incredibly tough to follow and difficult to maintain.</p>\r\n\r\n<p>JavaScript promises are formally defined by <a href=\"http://wiki.commonjs.org/wiki/Promises\" target=\"_blank\">CommonJS</a>. There are many implementations that have been developed, but two that you will see most often in both client and server side development are jQuery and Q implementations. <em>(jQuery on the client and Q in both client and server)</em></p>\r\n\r\n<p>Let's create a very basic scenario. </p>\r\n\r\n<p>We are waiting for a countdown to complete before we can continue further processing. The countdown gives us a 'promise' that it will let us know it is done and then blocks, and when the promise is resolved we can continue processing. <a href='/artifacts/javascript-promises/javascript-promises.html' target=\"_blank\">Click here</a> for a live example.</p>\r\n\r\n<p>The main application is pretty simple. We create our 'Timer Models' and we wait for processing to occur:</p>\r\n\r\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">var</span> jQueryTimer = <span style=\"color:Blue;\">new</span> app_ns.JQueryTimer(),\r\n    qTimer = <span style=\"color:Blue;\">new</span> app_ns.QTimer(),\r\n    timerDiv = $(<span style=\"color:#A31515;\">&#39;#timer&#39;</span>),\r\n    timer2Div = $(<span style=\"color:#A31515;\">&#39;#timer2&#39;</span>),\r\n    messageDiv = $(<span style=\"color:#A31515;\">&#39;#message&#39;</span>);\r\n\r\njQueryTimer.startCountDown(5).progress(<span style=\"color:Blue;\">function</span> (data) {\r\n    timerDiv.text(data.time);\r\n}).then(<span style=\"color:Blue;\">function</span> () {\r\n    timerDiv.text(<span style=\"color:#A31515;\">&#39;Blast off!&#39;</span>);\r\n}).then(<span style=\"color:Blue;\">function</span>() {\r\n    qTimer.startCountDown(5).progress(<span style=\"color:Blue;\">function</span> (data) {\r\n        timer2Div.text(data.time);\r\n    }).then(<span style=\"color:Blue;\">function</span> () {\r\n        timer2Div.text(<span style=\"color:#A31515;\">&#39;Blast off!&#39;</span>);\r\n    }).then(<span style=\"color:Blue;\">function</span>() {\r\n        messageDiv.text(<span style=\"color:#A31515;\">&#39;Both promises have been resolved.&#39;</span>);\r\n    });\r\n});\r\n</pre></div>\r\n\r\n<p>The actual configuration of the promise happens in the models. We create the deffered object, return it to the caller, and then resolve it when the promise has been fulfilled. The notify method is only used to send progress updates.</p>\r\n\r\n<p>The jQuery Model:</p>\r\n\r\n<div style=\"color:Black;background-color:White;\"><pre>\r\napp_ns.JQueryTimer = (<span style=\"color:Blue;\">function</span> ($) {\r\n    <span style=\"color:Blue;\">var</span> self = <span style=\"color:Blue;\">this</span>;\r\n    <span style=\"color:Blue;\">var</span> currentTime = 0;\r\n\r\n    <span style=\"color:Blue;\">var</span> startCountDown = <span style=\"color:Blue;\">function</span> (initialTime) {\r\n        <span style=\"color:Blue;\">var</span> deferred = $.Deferred();\r\n        currentTime = initialTime;\r\n\r\n        <span style=\"color:Blue;\">var</span> counter = setInterval(<span style=\"color:Blue;\">function</span> () {\r\n            deferred.notify({\r\n                time: currentTime\r\n            });\r\n\r\n            currentTime = currentTime - 1;\r\n\r\n            <span style=\"color:Blue;\">if</span> (currentTime &lt; 0) {\r\n                clearInterval(counter);\r\n                deferred.resolve();\r\n            }\r\n        }, 1000);\r\n\r\n        <span style=\"color:Blue;\">return</span> deferred.promise();\r\n    };\r\n\r\n  <span style=\"color:Blue;\">var</span> api = <span style=\"color:Blue;\">function</span>() {\r\n    <span style=\"color:Blue;\">this</span>.startCountDown = startCountDown;\r\n  };\r\n\r\n  <span style=\"color:Blue;\">return</span> api;\r\n})(jQuery);\r\n</pre></div>\r\n\r\n<p>And now the Q model which is identical in all but a couple of minor syntactical nuances:</p>\r\n\r\n<div style=\"color:Black;background-color:White;\"><pre>\r\napp_ns.QTimer = (<span style=\"color:Blue;\">function</span> (Q) {\r\n    <span style=\"color:Blue;\">var</span> self = <span style=\"color:Blue;\">this</span>;\r\n    <span style=\"color:Blue;\">var</span> currentTime = 0;\r\n\r\n    <span style=\"color:Blue;\">var</span> startCountDown = <span style=\"color:Blue;\">function</span> (initialTime) {\r\n        <span style=\"color:Blue;\">var</span> deferred = Q.defer();\r\n        currentTime = initialTime;\r\n\r\n        <span style=\"color:Blue;\">var</span> counter = setInterval(<span style=\"color:Blue;\">function</span> () {\r\n            deferred.notify({\r\n                time: currentTime\r\n            });\r\n\r\n            currentTime = currentTime - 1;\r\n\r\n            <span style=\"color:Blue;\">if</span> (currentTime &lt; 0) {\r\n                clearInterval(counter);\r\n                deferred.resolve();\r\n            }\r\n        }, 1000);\r\n\r\n        <span style=\"color:Blue;\">return</span> deferred.promise;\r\n    };\r\n\r\n  <span style=\"color:Blue;\">var</span> api = <span style=\"color:Blue;\">function</span>() {\r\n    <span style=\"color:Blue;\">this</span>.startCountDown = startCountDown;\r\n  };\r\n\r\n  <span style=\"color:Blue;\">return</span> api;\r\n})(Q);\r\n</pre></div>\r\n\r\n<p>That's about it for a basic, raw promise. In coming articles we will examine even more scenarios where promises can make our code cleaner and more concise.</p>\r\n","MarkdownContent":null,"Id":"fa363015-0946-4175-b44d-491aeb7cdc38","PublishDate":"2013-12-08T00:00:00","Tags":[],"Title":"JavaScript Promises","Comments":[],"ScriptDependencies":[],"SearchableContent":""}