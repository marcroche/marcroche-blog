{"Author":"marcroche","Content":"#Visualizing Path Finding with D3.js\r\n\r\n<div>\r\n\t<time class=\"postinfo left-50 postdate\">February 15, 2014</time>\r\n</div>\r\n\r\nI am continuing my explorations into <a href=\"http://d3js.org/\" target=\"_blank\">D3</a> with visualizing path finding algorithms.\r\n\r\nTo use the demo below, draw some obstacles for the path finder to go around and then press start. It will search the grid, at a slowed speed for visualization, and find the shortest path to the end square.\r\n\r\n<div id=\"grid\" style=\"height: 500px\"></div>\r\n<button id=\"startButton\">Start</button>\r\n<button id=\"resetButton\">Reset</button>\r\n\r\n##The Core D3 Code\r\n\r\nThe D3 specific code for this application is contained in the following module.\r\n\r\n```JavaScript\r\nmr_com.Grid = (function (d3, Vertex, Edge) {\r\n    var self;\r\n    var id, rows, cols, squareSize, data;\r\n    var isMouseDown = false;\r\n    var isGridReady = true;\r\n    var grid, row, cell;\r\n\r\n    d3.select(window).on('mousedown', function () { isMouseDown = true; });\r\n    d3.select(window).on('mouseup', function () { isMouseDown = false; });\r\n\r\n    function init() {\r\n        grid = d3.select(id).append(\"svg\")\r\n            .attr(\"width\", cols * squareSize)\r\n            .attr(\"height\", rows * squareSize)\r\n            .attr(\"class\", \"chart\");\r\n\r\n        row = grid.selectAll('.row')\r\n            .data(data, function (d) {\r\n                return data.indexOf(d);\r\n            })\r\n            .enter()\r\n            .append(\"svg:g\")\r\n          .attr(\"class\", \"row\");\r\n\r\n        cell = row.selectAll('.cell')\r\n          .data(function (d) {\r\n              return d;\r\n          },\r\n              function (d) {\r\n                  return d.key;\r\n              })\r\n          .enter()\r\n          .append('rect')\r\n          .attr('x', function (d, i, r) {\r\n              return i * squareSize;\r\n          })\r\n          .attr('y', function (d, i, r) {\r\n              return r * squareSize;\r\n          })\r\n          .attr('width', squareSize)\r\n          .attr('height', squareSize)\r\n              .attr('class', 'cell')\r\n          .style('fill', function (d) {\r\n              return d.visited === false ? 'white' : 'blue';\r\n          })\r\n          .style(\"stroke\", '#A5A5A5')\r\n          .on('mouseover', function (d, i, a, p) {\r\n              if (d.isBlocked === false && isGridReady) {\r\n                  d3.select(this).style(\"fill\", \"#E2E2E2\");\r\n              }\r\n\r\n              if (isMouseDown && isGridReady) {\r\n                  d.isBlocked = true;\r\n                  d3.select(this).style(\"fill\", \"#05056B\");\r\n                  d3.select(this).style(\"stroke\", \"#676767\");\r\n              }\r\n          })\r\n        .on('mouseout', function (d, i) {\r\n            if (d.isBlocked === false && isGridReady) {\r\n                d3.select(this).style(\"fill\", \"white\");\r\n            }\r\n        })\r\n        .on('mousedown', function (d, i) {\r\n            if (d.isBlocked === false && isGridReady) {\r\n                d.isBlocked = true;\r\n                d3.select(this).style(\"fill\", \"#05056B\");\r\n                d3.select(this).style(\"stroke\", \"#676767\");\r\n            } else if (isGridReady) {\r\n                d.isBlocked = false;\r\n                d3.select(this).style(\"fill\", \"#E2E2E2\");\r\n                d3.select(this).style(\"stroke\", '#A5A5A5');\r\n            }\r\n        });\r\n    }\r\n\r\n    function update() {\r\n        var r = grid.selectAll('.row')\r\n          .data(data, function (d) {\r\n              return data.indexOf(d);\r\n          });\r\n\r\n        var c = r.selectAll('rect')\r\n              .data(function (d) {\r\n                  return d;\r\n              }, function (d) {\r\n                  return d.key;\r\n              })\r\n            .transition()\r\n            .style('fill', function (d) {\r\n                var fill = 'white';\r\n                if (d.visited) {\r\n                    fill = '#67CCFE';\r\n                }\r\n                if (d.isBlocked) {\r\n                    fill = \"#05056B\";\r\n                }\r\n                if (d.isStart) {\r\n                    fill = '#87FF6F';\r\n                }\r\n                if (d.isEnd) {\r\n                    fill = '#FF0F0F';\r\n                }\r\n                if (d.isOnPath) {\r\n                    fill = '#FFF886';\r\n                }\r\n                return fill;\r\n            });\r\n    }\r\n\r\n    function complete() {\r\n        isGridReady = false;\r\n    }\r\n\r\n    function reset(_data) {\r\n        data = _data;\r\n        isGridReady = true;\r\n        update();\r\n    }\r\n\r\n    var api = function (_id, _rows, _cols, _squareSize, _data) {\r\n        self = this;\r\n        data = _data;\r\n        id = _id;\r\n        cols = _cols;\r\n        rows = _rows;\r\n        squareSize = _squareSize;\r\n\r\n        init();\r\n\r\n        this.update = update;\r\n        this.reset = reset;\r\n        this.complete = complete;\r\n    };\r\n\r\n    return api;\r\n})(d3, mr_com.Vertex, mr_com.Edge);\r\n```\r\n\r\nThe important areas to note are the init() and update() functions. These guys handle the D3 selections and this is where most of the magic happens.\r\n\r\n**init()**<br />\r\nIn this function we handle the D3 enter selection and we add the svg and grid elements. We also handle basic formatting and setup our event handlers.\r\n\r\nOne interesting aspect to point out is how the nested selections work. Select svg, select row, select cells.\r\n\r\nWe handle the events in the .on() functions that D3 provides.\r\n\r\n**update()**<br />\r\nThis function uses the transition selection to handle updates to our data. It then applies these changes to the existing elements.\r\n\r\nSince we don't remove elements after the initial creation we never use the exit selection.\r\n\r\nThe other code is for managing the state of the data.\r\n\r\n##The Search Algorithm\r\n\r\nFor the initial implementation I am using Dijkstra's algorithm to search the grid. The implementation follows:\r\n\r\n```JavaScript\r\n//TODO: Update this with hasPathTo\r\n mr_com.Dijkstra = (function(MinPriorityQueue, Q) {\r\n\r\n \tvar priorityQueue;\r\n \tvar distTo = [];\r\n \tvar shortestEdges = [];\r\n \tvar startVertex, endVertex;\r\n\r\n \tfunction relax(edge) {\r\n\t  var source = edge.source;\r\n\t  var target = edge.target;\r\n\t  \r\n\t  if(target.isBlocked) {\r\n\t   return; \r\n\t  }\r\n\t  \r\n\t  if(target.cost > source.cost + edge.weight) {\r\n\t    target.cost = source.cost + edge.weight;\r\n\t    \r\n\t    var se = _.findWhere(shortestEdges, { key: target.key });\r\n\t    if(se !== undefined) {\r\n\t      se.edge = edge;\r\n\t    } else {\r\n\t      shortestEdges.push({ key: target.key, edge: edge});\r\n\t    }\r\n\t    \r\n\t    if(priorityQueue.contains(target.key)) {\r\n\t       priorityQueue.decreaseKey(target.heapIndex, target.cost);\r\n\t    } else {\r\n\t      priorityQueue.push(target);\r\n\t    }\r\n\t  }\r\n\t};\r\n\r\n\tfunction shortestPath(destinationKey) {\r\n\t  var path = [];\r\n\t  var e = _.findWhere(shortestEdges, { key: destinationKey });\r\n\t  \r\n\t  if (!hasPathTo(e)) {\r\n\t      return path;\r\n\t  }\r\n\r\n\t  while(e !== undefined) {\r\n\t    e = _.findWhere(shortestEdges, { key: e.edge.source.key });\r\n\t    path.unshift(e);\r\n\t  }\r\n\t  return path;\r\n\t};\r\n\r\n\tfunction search() {\r\n\t\tvar deferred = Q.defer();\r\n\t\tvar runner = setInterval(function () {\r\n\t\t  var v = priorityQueue.pop();\r\n\t\t  v.heapIndex = -1;\r\n\t\t  for(var i = 0; i < v.edges.length; i++) {\r\n\t\t    relax(v.edges[i]);\r\n\t\t  }\r\n\t\t  v.visited = true;\r\n\t\t  deferred.notify({\r\n            status: 'visited'\r\n\t      });\r\n\t\t  \r\n\t\t  if(priorityQueue.isEmpty()) {\r\n\t\t   clearInterval(runner);\r\n\t\t    var sp = shortestPath(endVertex.key);\r\n\t\t    for(var s = 0; s < sp.length; s++) {\r\n\t\t      if(sp[s] !== undefined) {\r\n\t\t       sp[s].edge.target.isOnPath = true; \r\n\t\t      }\r\n\t\t    }\r\n\t\t    deferred.notify({\r\n\t          status: 'complete'\r\n\t\t    });\r\n\t\t    deferred.resolve();\r\n\t\t  }\r\n\t\t}, 25);\r\n\r\n\t\treturn deferred.promise;\r\n\t};\r\n\r\n \tvar api = function(_startVertex, _endVertex) {\r\n \t\tstartVertex = _startVertex;\r\n \t\tendVertex = _endVertex;\r\n \t\tpriorityQueue = new MinPriorityQueue('key', 'cost', []);\r\n \t\tpriorityQueue.push(startVertex);\r\n\r\n \t\tthis.search = search;\r\n \t};\r\n\r\n \treturn api;\r\n\r\n })(mr_com.MinPriorityQueue, Q);\r\n```\r\n\r\n\r\n##The Core Data Structures\r\n\r\n```JavaScript\r\nmr_com.GridGraph = (function(Vertex, Edge) {\r\n\tvar vertices = [];\r\n\r\n\tvar self;\r\n\tvar cols;\r\n\tvar rows;\r\n\t\r\n\tfunction findNeighbors() {\r\n\t  for(var r = 0; r < rows; r++) {\r\n\t    for(var c = 0; c < cols; c++) {\r\n\t      if(c - 1 >= 0) {\r\n\t        vertices[r][c].edges.push(new Edge(vertices[r][c], vertices[r][c - 1], 1.0));\r\n\t      }\r\n\t      \r\n\t      if(c + 1 < cols) {\r\n\t        vertices[r][c].edges.push(new Edge(vertices[r][c], vertices[r][c + 1], 1.0));\r\n\t      }\r\n\t      \r\n\t      if(r - 1 >= 0) {\r\n\t        vertices[r][c].edges.push(new Edge(vertices[r][c], vertices[r - 1][c], 1.0));\r\n\t      }\r\n\t      \r\n\t      if(r + 1 < rows) {\r\n\t        vertices[r][c].edges.push(new Edge(vertices[r][c], vertices[r + 1][c], 1.0));\r\n\t      }\r\n\t    }\r\n\t  }\r\n\t}\r\n\r\n\tfunction createGraph(_rows, _cols) {\r\n\t\tvertices = [];\r\n\t\tfor(var i = 0; i < rows; i++) {\r\n\t\t  var r = [];\r\n\t\t  for (var j = 0; j < cols; j++) {\r\n\t\t    r.push(new Vertex(i, j));\r\n\t\t  }\r\n\t\t  vertices.push(r);\r\n\t\t}\r\n\t}\r\n\r\n\tvar api = function(_rows, _cols) {\r\n\t\tself = this;\r\n\t\trows = _rows;\r\n\t\tcols = _cols;\r\n\r\n\t\tcreateGraph(rows, cols);\r\n\t\tfindNeighbors();\r\n\r\n\t\tthis.vertices = vertices;\r\n\t};\r\n\r\n\treturn api;\r\n})(mr_com.Vertex, mr_com.Edge);\r\n```\r\n\r\n```JavaScript\r\nmr_com.Vertex = function(row, column) {\r\n  \r\n  this.key = '[' + row + ',' + column + ']';\r\n  this.row = row;\r\n  this.column = column;\r\n  \r\n\r\n  this.heapIndex = -1;\r\n  this.visited = false;\r\n  this.isOnPath = false;\r\n  this.cost = Number.POSITIVE_INFINITY;\r\n  this.edges = [];\r\n\r\n\r\n  this.isBlocked = false;\r\n  this.isStart = false;\r\n  this.isEnd = false;\r\n\r\n  this.reset = function() {\r\n    this.heapIndex = -1;\r\n    this.visited = false;\r\n    this.isOnPath = false;\r\n    this.cost = Number.POSITIVE_INFINITY;\r\n    this.isBlocked = false;\r\n    this.isStart = false;\r\n    this.isEnd = false;\r\n  }\r\n};\r\n```\r\n\r\n```JavaScript\r\nmr_com.Edge = function(source, target, weight) {\r\n  this.weight = weight;\r\n  this.target = target;\r\n  this.source = source;\r\n};\r\n```","HtmlContent":"<h1>Visualizing Path Finding with D3.js</h1>\r\n\r\n<div>\r\n    <time class=\"postinfo left-50 postdate\">February 15, 2014</time>\r\n</div>\r\n\r\n<p>I am continuing my explorations into <a href=\"http://d3js.org/\" target=\"_blank\">D3</a> with visualizing path finding algorithms.</p>\r\n\r\n<p>To use the demo below, draw some obstacles for the path finder to go around and then press start. It will search the grid, at a slowed speed for visualization, and find the shortest path to the end square.</p>\r\n\r\n<div id=\"grid\" style=\"height: 500px\"></div>\r\n\r\n<p><button id=\"startButton\">Start</button>\r\n<button id=\"resetButton\">Reset</button></p>\r\n\r\n<h2>The Core D3 Code</h2>\r\n\r\n<p>The D3 specific code for this application is contained in the following module.</p>\r\n\r\n<div style=\"color:Black;background-color:White;\"><pre>\r\nmr_com.Grid = (<span style=\"color:Blue;\">function</span> (d3, Vertex, Edge) {\r\n    <span style=\"color:Blue;\">var</span> self;\r\n    <span style=\"color:Blue;\">var</span> id, rows, cols, squareSize, data;\r\n    <span style=\"color:Blue;\">var</span> isMouseDown = <span style=\"color:Blue;\">false</span>;\r\n    <span style=\"color:Blue;\">var</span> isGridReady = <span style=\"color:Blue;\">true</span>;\r\n    <span style=\"color:Blue;\">var</span> grid, row, cell;\r\n\r\n    d3.select(window).on(<span style=\"color:#A31515;\">&#39;mousedown&#39;</span>, <span style=\"color:Blue;\">function</span> () { isMouseDown = <span style=\"color:Blue;\">true</span>; });\r\n    d3.select(window).on(<span style=\"color:#A31515;\">&#39;mouseup&#39;</span>, <span style=\"color:Blue;\">function</span> () { isMouseDown = <span style=\"color:Blue;\">false</span>; });\r\n\r\n    <span style=\"color:Blue;\">function</span> init() {\r\n        grid = d3.select(id).append(<span style=\"color:#A31515;\">&quot;svg&quot;</span>)\r\n            .attr(<span style=\"color:#A31515;\">&quot;width&quot;</span>, cols * squareSize)\r\n            .attr(<span style=\"color:#A31515;\">&quot;height&quot;</span>, rows * squareSize)\r\n            .attr(<span style=\"color:#A31515;\">&quot;class&quot;</span>, <span style=\"color:#A31515;\">&quot;chart&quot;</span>);\r\n\r\n        row = grid.selectAll(<span style=\"color:#A31515;\">&#39;.row&#39;</span>)\r\n            .data(data, <span style=\"color:Blue;\">function</span> (d) {\r\n                <span style=\"color:Blue;\">return</span> data.indexOf(d);\r\n            })\r\n            .enter()\r\n            .append(<span style=\"color:#A31515;\">&quot;svg:g&quot;</span>)\r\n          .attr(<span style=\"color:#A31515;\">&quot;class&quot;</span>, <span style=\"color:#A31515;\">&quot;row&quot;</span>);\r\n\r\n        cell = row.selectAll(<span style=\"color:#A31515;\">&#39;.cell&#39;</span>)\r\n          .data(<span style=\"color:Blue;\">function</span> (d) {\r\n              <span style=\"color:Blue;\">return</span> d;\r\n          },\r\n              <span style=\"color:Blue;\">function</span> (d) {\r\n                  <span style=\"color:Blue;\">return</span> d.key;\r\n              })\r\n          .enter()\r\n          .append(<span style=\"color:#A31515;\">&#39;rect&#39;</span>)\r\n          .attr(<span style=\"color:#A31515;\">&#39;x&#39;</span>, <span style=\"color:Blue;\">function</span> (d, i, r) {\r\n              <span style=\"color:Blue;\">return</span> i * squareSize;\r\n          })\r\n          .attr(<span style=\"color:#A31515;\">&#39;y&#39;</span>, <span style=\"color:Blue;\">function</span> (d, i, r) {\r\n              <span style=\"color:Blue;\">return</span> r * squareSize;\r\n          })\r\n          .attr(<span style=\"color:#A31515;\">&#39;width&#39;</span>, squareSize)\r\n          .attr(<span style=\"color:#A31515;\">&#39;height&#39;</span>, squareSize)\r\n              .attr(<span style=\"color:#A31515;\">&#39;class&#39;</span>, <span style=\"color:#A31515;\">&#39;cell&#39;</span>)\r\n          .style(<span style=\"color:#A31515;\">&#39;fill&#39;</span>, <span style=\"color:Blue;\">function</span> (d) {\r\n              <span style=\"color:Blue;\">return</span> d.visited === <span style=\"color:Blue;\">false</span> ? <span style=\"color:#A31515;\">&#39;white&#39;</span> : <span style=\"color:#A31515;\">&#39;blue&#39;</span>;\r\n          })\r\n          .style(<span style=\"color:#A31515;\">&quot;stroke&quot;</span>, <span style=\"color:#A31515;\">&#39;#A5A5A5&#39;</span>)\r\n          .on(<span style=\"color:#A31515;\">&#39;mouseover&#39;</span>, <span style=\"color:Blue;\">function</span> (d, i, a, p) {\r\n              <span style=\"color:Blue;\">if</span> (d.isBlocked === <span style=\"color:Blue;\">false</span> &amp;&amp; isGridReady) {\r\n                  d3.select(<span style=\"color:Blue;\">this</span>).style(<span style=\"color:#A31515;\">&quot;fill&quot;</span>, <span style=\"color:#A31515;\">&quot;#E2E2E2&quot;</span>);\r\n              }\r\n\r\n              <span style=\"color:Blue;\">if</span> (isMouseDown &amp;&amp; isGridReady) {\r\n                  d.isBlocked = <span style=\"color:Blue;\">true</span>;\r\n                  d3.select(<span style=\"color:Blue;\">this</span>).style(<span style=\"color:#A31515;\">&quot;fill&quot;</span>, <span style=\"color:#A31515;\">&quot;#05056B&quot;</span>);\r\n                  d3.select(<span style=\"color:Blue;\">this</span>).style(<span style=\"color:#A31515;\">&quot;stroke&quot;</span>, <span style=\"color:#A31515;\">&quot;#676767&quot;</span>);\r\n              }\r\n          })\r\n        .on(<span style=\"color:#A31515;\">&#39;mouseout&#39;</span>, <span style=\"color:Blue;\">function</span> (d, i) {\r\n            <span style=\"color:Blue;\">if</span> (d.isBlocked === <span style=\"color:Blue;\">false</span> &amp;&amp; isGridReady) {\r\n                d3.select(<span style=\"color:Blue;\">this</span>).style(<span style=\"color:#A31515;\">&quot;fill&quot;</span>, <span style=\"color:#A31515;\">&quot;white&quot;</span>);\r\n            }\r\n        })\r\n        .on(<span style=\"color:#A31515;\">&#39;mousedown&#39;</span>, <span style=\"color:Blue;\">function</span> (d, i) {\r\n            <span style=\"color:Blue;\">if</span> (d.isBlocked === <span style=\"color:Blue;\">false</span> &amp;&amp; isGridReady) {\r\n                d.isBlocked = <span style=\"color:Blue;\">true</span>;\r\n                d3.select(<span style=\"color:Blue;\">this</span>).style(<span style=\"color:#A31515;\">&quot;fill&quot;</span>, <span style=\"color:#A31515;\">&quot;#05056B&quot;</span>);\r\n                d3.select(<span style=\"color:Blue;\">this</span>).style(<span style=\"color:#A31515;\">&quot;stroke&quot;</span>, <span style=\"color:#A31515;\">&quot;#676767&quot;</span>);\r\n            } <span style=\"color:Blue;\">else</span> <span style=\"color:Blue;\">if</span> (isGridReady) {\r\n                d.isBlocked = <span style=\"color:Blue;\">false</span>;\r\n                d3.select(<span style=\"color:Blue;\">this</span>).style(<span style=\"color:#A31515;\">&quot;fill&quot;</span>, <span style=\"color:#A31515;\">&quot;#E2E2E2&quot;</span>);\r\n                d3.select(<span style=\"color:Blue;\">this</span>).style(<span style=\"color:#A31515;\">&quot;stroke&quot;</span>, <span style=\"color:#A31515;\">&#39;#A5A5A5&#39;</span>);\r\n            }\r\n        });\r\n    }\r\n\r\n    <span style=\"color:Blue;\">function</span> update() {\r\n        <span style=\"color:Blue;\">var</span> r = grid.selectAll(<span style=\"color:#A31515;\">&#39;.row&#39;</span>)\r\n          .data(data, <span style=\"color:Blue;\">function</span> (d) {\r\n              <span style=\"color:Blue;\">return</span> data.indexOf(d);\r\n          });\r\n\r\n        <span style=\"color:Blue;\">var</span> c = r.selectAll(<span style=\"color:#A31515;\">&#39;rect&#39;</span>)\r\n              .data(<span style=\"color:Blue;\">function</span> (d) {\r\n                  <span style=\"color:Blue;\">return</span> d;\r\n              }, <span style=\"color:Blue;\">function</span> (d) {\r\n                  <span style=\"color:Blue;\">return</span> d.key;\r\n              })\r\n            .transition()\r\n            .style(<span style=\"color:#A31515;\">&#39;fill&#39;</span>, <span style=\"color:Blue;\">function</span> (d) {\r\n                <span style=\"color:Blue;\">var</span> fill = <span style=\"color:#A31515;\">&#39;white&#39;</span>;\r\n                <span style=\"color:Blue;\">if</span> (d.visited) {\r\n                    fill = <span style=\"color:#A31515;\">&#39;#67CCFE&#39;</span>;\r\n                }\r\n                <span style=\"color:Blue;\">if</span> (d.isBlocked) {\r\n                    fill = <span style=\"color:#A31515;\">&quot;#05056B&quot;</span>;\r\n                }\r\n                <span style=\"color:Blue;\">if</span> (d.isStart) {\r\n                    fill = <span style=\"color:#A31515;\">&#39;#87FF6F&#39;</span>;\r\n                }\r\n                <span style=\"color:Blue;\">if</span> (d.isEnd) {\r\n                    fill = <span style=\"color:#A31515;\">&#39;#FF0F0F&#39;</span>;\r\n                }\r\n                <span style=\"color:Blue;\">if</span> (d.isOnPath) {\r\n                    fill = <span style=\"color:#A31515;\">&#39;#FFF886&#39;</span>;\r\n                }\r\n                <span style=\"color:Blue;\">return</span> fill;\r\n            });\r\n    }\r\n\r\n    <span style=\"color:Blue;\">function</span> complete() {\r\n        isGridReady = <span style=\"color:Blue;\">false</span>;\r\n    }\r\n\r\n    <span style=\"color:Blue;\">function</span> reset(_data) {\r\n        data = _data;\r\n        isGridReady = <span style=\"color:Blue;\">true</span>;\r\n        update();\r\n    }\r\n\r\n    <span style=\"color:Blue;\">var</span> api = <span style=\"color:Blue;\">function</span> (_id, _rows, _cols, _squareSize, _data) {\r\n        self = <span style=\"color:Blue;\">this</span>;\r\n        data = _data;\r\n        id = _id;\r\n        cols = _cols;\r\n        rows = _rows;\r\n        squareSize = _squareSize;\r\n\r\n        init();\r\n\r\n        <span style=\"color:Blue;\">this</span>.update = update;\r\n        <span style=\"color:Blue;\">this</span>.reset = reset;\r\n        <span style=\"color:Blue;\">this</span>.complete = complete;\r\n    };\r\n\r\n    <span style=\"color:Blue;\">return</span> api;\r\n})(d3, mr_com.Vertex, mr_com.Edge);\r\n</pre></div>\r\n\r\n<p>The important areas to note are the init() and update() functions. These guys handle the D3 selections and this is where most of the magic happens.</p>\r\n\r\n<p><strong>init()</strong><br />\r\nIn this function we handle the D3 enter selection and we add the svg and grid elements. We also handle basic formatting and setup our event handlers.</p>\r\n\r\n<p>One interesting aspect to point out is how the nested selections work. Select svg, select row, select cells.</p>\r\n\r\n<p>We handle the events in the .on() functions that D3 provides.</p>\r\n\r\n<p><strong>update()</strong><br />\r\nThis function uses the transition selection to handle updates to our data. It then applies these changes to the existing elements.</p>\r\n\r\n<p>Since we don't remove elements after the initial creation we never use the exit selection.</p>\r\n\r\n<p>The other code is for managing the state of the data.</p>\r\n\r\n<h2>The Search Algorithm</h2>\r\n\r\n<p>For the initial implementation I am using Dijkstra's algorithm to search the grid. The implementation follows:</p>\r\n\r\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Green;\">//TODO: Update this with hasPathTo</span>\r\n mr_com.Dijkstra = (<span style=\"color:Blue;\">function</span>(MinPriorityQueue, Q) {\r\n\r\n    <span style=\"color:Blue;\">var</span> priorityQueue;\r\n    <span style=\"color:Blue;\">var</span> distTo = [];\r\n    <span style=\"color:Blue;\">var</span> shortestEdges = [];\r\n    <span style=\"color:Blue;\">var</span> startVertex, endVertex;\r\n\r\n    <span style=\"color:Blue;\">function</span> relax(edge) {\r\n      <span style=\"color:Blue;\">var</span> source = edge.source;\r\n      <span style=\"color:Blue;\">var</span> target = edge.target;\r\n\r\n      <span style=\"color:Blue;\">if</span>(target.isBlocked) {\r\n       <span style=\"color:Blue;\">return</span>; \r\n      }\r\n\r\n      <span style=\"color:Blue;\">if</span>(target.cost &gt; source.cost + edge.weight) {\r\n        target.cost = source.cost + edge.weight;\r\n\r\n        <span style=\"color:Blue;\">var</span> se = _.findWhere(shortestEdges, { key: target.key });\r\n        <span style=\"color:Blue;\">if</span>(se !== undefined) {\r\n          se.edge = edge;\r\n        } <span style=\"color:Blue;\">else</span> {\r\n          shortestEdges.push({ key: target.key, edge: edge});\r\n        }\r\n\r\n        <span style=\"color:Blue;\">if</span>(priorityQueue.contains(target.key)) {\r\n           priorityQueue.decreaseKey(target.heapIndex, target.cost);\r\n        } <span style=\"color:Blue;\">else</span> {\r\n          priorityQueue.push(target);\r\n        }\r\n      }\r\n    };\r\n\r\n    <span style=\"color:Blue;\">function</span> shortestPath(destinationKey) {\r\n      <span style=\"color:Blue;\">var</span> path = [];\r\n      <span style=\"color:Blue;\">var</span> e = _.findWhere(shortestEdges, { key: destinationKey });\r\n\r\n      <span style=\"color:Blue;\">if</span> (!hasPathTo(e)) {\r\n          <span style=\"color:Blue;\">return</span> path;\r\n      }\r\n\r\n      <span style=\"color:Blue;\">while</span>(e !== undefined) {\r\n        e = _.findWhere(shortestEdges, { key: e.edge.source.key });\r\n        path.unshift(e);\r\n      }\r\n      <span style=\"color:Blue;\">return</span> path;\r\n    };\r\n\r\n    <span style=\"color:Blue;\">function</span> search() {\r\n        <span style=\"color:Blue;\">var</span> deferred = Q.defer();\r\n        <span style=\"color:Blue;\">var</span> runner = setInterval(<span style=\"color:Blue;\">function</span> () {\r\n          <span style=\"color:Blue;\">var</span> v = priorityQueue.pop();\r\n          v.heapIndex = -1;\r\n          <span style=\"color:Blue;\">for</span>(<span style=\"color:Blue;\">var</span> i = 0; i &lt; v.edges.length; i++) {\r\n            relax(v.edges[i]);\r\n          }\r\n          v.visited = <span style=\"color:Blue;\">true</span>;\r\n          deferred.notify({\r\n            status: <span style=\"color:#A31515;\">&#39;visited&#39;</span>\r\n          });\r\n\r\n          <span style=\"color:Blue;\">if</span>(priorityQueue.isEmpty()) {\r\n           clearInterval(runner);\r\n            <span style=\"color:Blue;\">var</span> sp = shortestPath(endVertex.key);\r\n            <span style=\"color:Blue;\">for</span>(<span style=\"color:Blue;\">var</span> s = 0; s &lt; sp.length; s++) {\r\n              <span style=\"color:Blue;\">if</span>(sp[s] !== undefined) {\r\n               sp[s].edge.target.isOnPath = <span style=\"color:Blue;\">true</span>; \r\n              }\r\n            }\r\n            deferred.notify({\r\n              status: <span style=\"color:#A31515;\">&#39;complete&#39;</span>\r\n            });\r\n            deferred.resolve();\r\n          }\r\n        }, 25);\r\n\r\n        <span style=\"color:Blue;\">return</span> deferred.promise;\r\n    };\r\n\r\n    <span style=\"color:Blue;\">var</span> api = <span style=\"color:Blue;\">function</span>(_startVertex, _endVertex) {\r\n        startVertex = _startVertex;\r\n        endVertex = _endVertex;\r\n        priorityQueue = <span style=\"color:Blue;\">new</span> MinPriorityQueue(<span style=\"color:#A31515;\">&#39;key&#39;</span>, <span style=\"color:#A31515;\">&#39;cost&#39;</span>, []);\r\n        priorityQueue.push(startVertex);\r\n\r\n        <span style=\"color:Blue;\">this</span>.search = search;\r\n    };\r\n\r\n    <span style=\"color:Blue;\">return</span> api;\r\n\r\n })(mr_com.MinPriorityQueue, Q);\r\n</pre></div>\r\n\r\n<h2>The Core Data Structures</h2>\r\n\r\n<div style=\"color:Black;background-color:White;\"><pre>\r\nmr_com.GridGraph = (<span style=\"color:Blue;\">function</span>(Vertex, Edge) {\r\n    <span style=\"color:Blue;\">var</span> vertices = [];\r\n\r\n    <span style=\"color:Blue;\">var</span> self;\r\n    <span style=\"color:Blue;\">var</span> cols;\r\n    <span style=\"color:Blue;\">var</span> rows;\r\n\r\n    <span style=\"color:Blue;\">function</span> findNeighbors() {\r\n      <span style=\"color:Blue;\">for</span>(<span style=\"color:Blue;\">var</span> r = 0; r &lt; rows; r++) {\r\n        <span style=\"color:Blue;\">for</span>(<span style=\"color:Blue;\">var</span> c = 0; c &lt; cols; c++) {\r\n          <span style=\"color:Blue;\">if</span>(c - 1 &gt;= 0) {\r\n            vertices[r][c].edges.push(<span style=\"color:Blue;\">new</span> Edge(vertices[r][c], vertices[r][c - 1], 1.0));\r\n          }\r\n\r\n          <span style=\"color:Blue;\">if</span>(c + 1 &lt; cols) {\r\n            vertices[r][c].edges.push(<span style=\"color:Blue;\">new</span> Edge(vertices[r][c], vertices[r][c + 1], 1.0));\r\n          }\r\n\r\n          <span style=\"color:Blue;\">if</span>(r - 1 &gt;= 0) {\r\n            vertices[r][c].edges.push(<span style=\"color:Blue;\">new</span> Edge(vertices[r][c], vertices[r - 1][c], 1.0));\r\n          }\r\n\r\n          <span style=\"color:Blue;\">if</span>(r + 1 &lt; rows) {\r\n            vertices[r][c].edges.push(<span style=\"color:Blue;\">new</span> Edge(vertices[r][c], vertices[r + 1][c], 1.0));\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    <span style=\"color:Blue;\">function</span> createGraph(_rows, _cols) {\r\n        vertices = [];\r\n        <span style=\"color:Blue;\">for</span>(<span style=\"color:Blue;\">var</span> i = 0; i &lt; rows; i++) {\r\n          <span style=\"color:Blue;\">var</span> r = [];\r\n          <span style=\"color:Blue;\">for</span> (<span style=\"color:Blue;\">var</span> j = 0; j &lt; cols; j++) {\r\n            r.push(<span style=\"color:Blue;\">new</span> Vertex(i, j));\r\n          }\r\n          vertices.push(r);\r\n        }\r\n    }\r\n\r\n    <span style=\"color:Blue;\">var</span> api = <span style=\"color:Blue;\">function</span>(_rows, _cols) {\r\n        self = <span style=\"color:Blue;\">this</span>;\r\n        rows = _rows;\r\n        cols = _cols;\r\n\r\n        createGraph(rows, cols);\r\n        findNeighbors();\r\n\r\n        <span style=\"color:Blue;\">this</span>.vertices = vertices;\r\n    };\r\n\r\n    <span style=\"color:Blue;\">return</span> api;\r\n})(mr_com.Vertex, mr_com.Edge);\r\n</pre></div>\r\n\r\n<div style=\"color:Black;background-color:White;\"><pre>\r\nmr_com.Vertex = <span style=\"color:Blue;\">function</span>(row, column) {\r\n\r\n  <span style=\"color:Blue;\">this</span>.key = <span style=\"color:#A31515;\">&#39;[&#39;</span> + row + <span style=\"color:#A31515;\">&#39;,&#39;</span> + column + <span style=\"color:#A31515;\">&#39;]&#39;</span>;\r\n  <span style=\"color:Blue;\">this</span>.row = row;\r\n  <span style=\"color:Blue;\">this</span>.column = column;\r\n\r\n\r\n  <span style=\"color:Blue;\">this</span>.heapIndex = -1;\r\n  <span style=\"color:Blue;\">this</span>.visited = <span style=\"color:Blue;\">false</span>;\r\n  <span style=\"color:Blue;\">this</span>.isOnPath = <span style=\"color:Blue;\">false</span>;\r\n  <span style=\"color:Blue;\">this</span>.cost = Number.POSITIVE_INFINITY;\r\n  <span style=\"color:Blue;\">this</span>.edges = [];\r\n\r\n\r\n  <span style=\"color:Blue;\">this</span>.isBlocked = <span style=\"color:Blue;\">false</span>;\r\n  <span style=\"color:Blue;\">this</span>.isStart = <span style=\"color:Blue;\">false</span>;\r\n  <span style=\"color:Blue;\">this</span>.isEnd = <span style=\"color:Blue;\">false</span>;\r\n\r\n  <span style=\"color:Blue;\">this</span>.reset = <span style=\"color:Blue;\">function</span>() {\r\n    <span style=\"color:Blue;\">this</span>.heapIndex = -1;\r\n    <span style=\"color:Blue;\">this</span>.visited = <span style=\"color:Blue;\">false</span>;\r\n    <span style=\"color:Blue;\">this</span>.isOnPath = <span style=\"color:Blue;\">false</span>;\r\n    <span style=\"color:Blue;\">this</span>.cost = Number.POSITIVE_INFINITY;\r\n    <span style=\"color:Blue;\">this</span>.isBlocked = <span style=\"color:Blue;\">false</span>;\r\n    <span style=\"color:Blue;\">this</span>.isStart = <span style=\"color:Blue;\">false</span>;\r\n    <span style=\"color:Blue;\">this</span>.isEnd = <span style=\"color:Blue;\">false</span>;\r\n  }\r\n};\r\n</pre></div>\r\n\r\n<div style=\"color:Black;background-color:White;\"><pre>\r\nmr_com.Edge = <span style=\"color:Blue;\">function</span>(source, target, weight) {\r\n  <span style=\"color:Blue;\">this</span>.weight = weight;\r\n  <span style=\"color:Blue;\">this</span>.target = target;\r\n  <span style=\"color:Blue;\">this</span>.source = source;\r\n};\r\n</pre></div>\r\n","MarkdownContent":null,"Id":"63cb5e5b-345f-4760-a069-56cc16fac5e6","PublishDate":"2014-02-15T00:00:00","Tags":[],"Title":"Path Finding with D3","Comments":[],"ScriptDependencies":["\n            <script data-main=\"/artifacts/path-finding-with-d3/app/main\" src=\"/artifacts/path-finding-with-d3/vendor/require.js\" type=\"text/javascript\"></script>\n        "],"SearchableContent":""}