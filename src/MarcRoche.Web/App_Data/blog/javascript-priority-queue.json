{"Author":"marcroche","Content":"#JavaScript Priority Queue\r\n\r\n<div>\r\n\t<time class=\"postinfo left-50 postdate\">January 28, 2014</time>\r\n</div>\r\n\r\nOne of the new projects I am starting up is using <a href=\"http://d3js.org/\" target=\"_blank\">D3</a> to visualize shortest path problems.\r\n\r\nAn infrastructure pre-requisite I will need in place to start this is a **Priority Queue**. This is a data structure that allows us to retrieve the minimum value, or maximum (depending on implementation), in the data set very efficiently. During the course of the path finding algorithm we will be pushing the path weights onto the queue and then retrieving the smallest one to determine the next step in the path.\r\n\r\nSo, let's consider a set of values in an array:<br />\r\n\r\n<img src=\"/artifacts/javascript-priority-queue/array.png\" class=\"array\" />\r\n\r\nCurrently this array is a set of unordered values with a linear structure. However, it could also be thought of as a nearly complete binary tree:<br />\r\n\r\n<img src=\"/artifacts/javascript-priority-queue/tree.png\" />\r\n\r\nOnce we think of the structure in this way, we can begin to use tree properties and methods to manipulate the data.\r\n\r\n##Binary Heaps##\r\n\r\nThe priority queue I am building is implemented on a Binary Heap data structure. Binary Heaps are complete, or nearly complete, binary trees with two additional properties.\r\n\r\n* **Shape Property** - The structure is a Binary Tree, or nearly complete Binary Tree. All levels must be fully filled, except possibly the last level. If that level is not filled it must be filled from left to right.\r\n* **Heap Property** - The nodes of the tree are either less than or equal to, or greater than or equal to, each of its children.\r\n\r\nUsually Binary Heaps are referred to as Min-Heaps or Max-Heaps depending on how the Heap Property is implemented. For the shortest path problems we will implement a Min-Heap for our Priority Queue.\r\n\r\n###Building the Heap###\r\n\r\nTo start we take the items from FLOOR((A.length - 1) / 2) down to zero and apply our MinHeapify algorithm. The reason for this is that these items will all be nodes, while the remaining items will all be leaves.\r\n\r\n```JavaScript\r\n// Size is A.length - 1 to compensate for a zero indexed array.\r\nfunction buildMinHeap(A, size) {\r\n\tfor(var i = Math.floor(size / 2); i >= 0; i--) { \r\n\t\tminHeapify(A, i, size); \r\n\t}\r\n}\r\n```\r\n\r\nNow that we have these items selected we will start applying our MinHeapify algorithm. We cycle through and determine if the current element at A[i], the left child, or the right child is the smallest. If the current element is already the smallest then the current sub-tree is a Min-Heap and we can go to the next node. If one of the children is the smallest we swap it with the root and we now have a sub-tree that is a Min-Heap.\r\n\r\nIn the situation where we swap a child value for the current index value we could have sub-tree rooted at A[smallest] that no longer meets the **Heap Property**. Therefore we need to recursively apply the MinHeapify algorithm to that sub-tree to repeat the process.\r\n\r\n```JavaScript\r\nfunction minHeapify(A, i, size) {\r\n\tvar l = left(i);\r\n\tvar r = right(i);\r\n\tvar smallest;\r\n    \r\n\tif(l <= size && A[l] < A[i]) {\r\n\t\tsmallest = l; \r\n\t} else {\r\n\t\tsmallest = i; \r\n\t}\r\n    \r\n\tif(r <= size && A[r] < A[smallest]) {\r\n\t\tsmallest = r; \r\n\t}\r\n    \r\n\tif(smallest != i) {\r\n\t\tvar tmp = A[i];\r\n\t\tA[i] = A[smallest];\r\n\t\tA[smallest] = tmp;\r\n      \r\n\t\tminHeapify(A, smallest, size);\r\n\t}\r\n}\r\n```\r\nWe now have a Min-Heap structure that meets the **Shape Property** and the **Heap Property**. It's worth noting that it is not necessarily in lowest to highest order within the array itself.<br />\r\n<img src=\"/artifacts/javascript-priority-queue/minheap.png\" />\r\n\r\n##Priority Queue##\r\n\r\nNow that we have our Binary Heap structure implementing the Priority Queue is trivial.\r\n\r\nFor our interface we will have four methods into the queue.\r\n\r\n* **Peek** will return the smallest value without removing it from the queue.\r\n* **Pop** will return the smallest value and remove it from the queue. This forces a reorganization of the nodes.\r\n* **Push** will insert a new value into the heap and organize it appropriately.\r\n* **Print** is a debugging function that will print out the array structure in order.\r\n\r\n###Peek###\r\n\r\nThis is probably the simplest method in the whole structure. It simply returns the item at the zero index of the array.\r\n\r\n```JavaScript\r\nfunction peek() {\r\n\tif(array.length < 1) {\r\n\t\tthrow 'Heap Underflow';\r\n\t}\r\n    \r\n\treturn array[0];\r\n}\r\n```\r\n\r\n###Pop###\r\n\r\nThis method is only slightly different from Peek. We return the minimum value from the array at index zero, but we also remove that item from the array. We then take the last item and move it to the front and run MinHeapify on the array to restructure it.\r\n\r\n```JavaScript\r\nfunction pop() {\r\n\tif(array.length < 1) {\r\n\t\tthrow 'Heap Underflow';\r\n\t}\r\n    \r\n\tvar min = array[0];\r\n\tarray[0] = array[array.length - 1];\r\n\tarray.splice(array.length - 1, 1);\r\n    \r\n\tminHeapify(array, 0, array.length - 1);\r\n    \r\n\treturn min;\r\n}\r\n```\r\n\r\n###Push###\r\n\r\nFor push we add the new value to the end of the array bubble is up to its appropriate location. We assume that we are already working with a structure that meets the **Heap Property**.\r\n\r\n```JavaScript\r\nfunction queue(value) {\r\n\tarray.push(value);\r\n\theapDecreaseKey(array, array.length - 1, value);\r\n}\r\n\r\nfunction heapDecreaseKey(A, i, key) {\r\n\twhile(i > 0 && A[parent(i)] > A[i]) {\r\n\t\tvar tmp = A[i];\r\n\t\tA[i] = A[parent(i)];\r\n\t\tA[parent(i)] = tmp;\r\n\t\ti = parent(i);\r\n\t}\r\n}\r\n```\r\n\r\n###Print###\r\n\r\nWith print we just cycle through the array and log the current value.\r\n\r\n```JavaScript\r\nfunction print() {\r\n\tfor(var i = 0; i < array.length; i++) {\r\n\t\tconsole.log(array[i]); \r\n\t}\r\n}\r\n```\r\n\r\n###The Complete Code###\r\n\r\nThat is it! We now have our Min-Priority Queue ready to go. The complete code looks like this:\r\n\r\n```JavaScript\r\napp_ns.MinPriorityQueue = (function() {\r\n  var array;\r\n  \r\n  function left(i) {\r\n    return 2 * i + 1;\r\n  }\r\n  \r\n  function right(i) {\r\n    return 2 * i + 2;\r\n  }\r\n  \r\n  function parent(i) {\r\n    return Math.floor(i / 2); \r\n  }\r\n  \r\n  function minHeapify(A, i, size) {\r\n    var l = left(i);\r\n    var r = right(i);\r\n    var largest;\r\n    \r\n    if(l <= size && A[l] < A[i]) {\r\n     largest = l; \r\n    } else {\r\n     largest = i; \r\n    }\r\n    \r\n    if(r <= size && A[r] < A[largest]) {\r\n     largest = r; \r\n    }\r\n    \r\n    if(largest != i) {\r\n      var tmp = A[i];\r\n      A[i] = A[largest];\r\n      A[largest] = tmp;\r\n      \r\n      minHeapify(A, largest, size);\r\n    }\r\n  }\r\n  \r\n  function buildMinHeap(A, size) {\r\n    for(var i = Math.floor(size / 2); i >= 0; i--) { \r\n     minHeapify(A, i, size); \r\n    }\r\n  }\r\n  \r\n  function peek() {\r\n    if(array.length < 1) {\r\n      throw 'Heap Underflow';\r\n    }\r\n    \r\n    return array[0];\r\n  }\r\n  \r\n  function pop() {\r\n    if(array.length < 1) {\r\n      throw 'Heap Underflow';\r\n    }\r\n    \r\n    var min = array[0];\r\n    array[0] = array[array.length - 1];\r\n    array.splice(array.length - 1, 1);\r\n    \r\n    minHeapify(array, 0, array.length - 1);\r\n    \r\n    return min;\r\n  }\r\n\r\n  function push(value) {\r\n    array.push(value);\r\n    heapDecreaseKey(array, array.length - 1, value);\r\n  }\r\n  \r\n  function print() {\r\n    for(var i = 0; i < array.length; i++) {\r\n     console.log(array[i]); \r\n    }\r\n  }\r\n  \r\n  function heapDecreaseKey(A, i, key) {\r\n    while(i > 0 && A[parent(i)] > A[i]) {\r\n      var tmp = A[i];\r\n      A[i] = A[parent(i)];\r\n      A[parent(i)] = tmp;\r\n      i = parent(i);\r\n    }\r\n  }\r\n  \r\n\r\n  \r\n  var api = function(arr) {\r\n    array = arr;\r\n    buildMinHeap(array, array.length -1);\r\n    \r\n    this.peek = peek;\r\n    this.pop = pop;\r\n    this.queue = queue;\r\n    this.print = print;\r\n  };\r\n  \r\n  return api;\r\n  \r\n})();\r\n```\r\nUsing this structure is very simple. To create a queue and initialize it with values looks like this: \r\n\r\n```JavaScript\r\nvar minQueue = new app_ns.MinPriorityQueue([11, 24, 22, 13, 9, 7, 8, 10, 14, 16]);\r\n```\r\n\r\nTo push values onto the queue:\r\n\r\n```JavaScript\r\nminQueue.push(1);\r\n```\r\n\r\nAnd to pop values from the queue:\r\n\r\n```JavaScript\r\nvar value = minQueue.pop();\r\n```","HtmlContent":"<h1>JavaScript Priority Queue</h1>\r\n\r\n<div>\r\n    <time class=\"postinfo left-50 postdate\">January 28, 2014</time>\r\n</div>\r\n\r\n<p>One of the new projects I am starting up is using <a href=\"http://d3js.org/\" target=\"_blank\">D3</a> to visualize shortest path problems.</p>\r\n\r\n<p>An infrastructure pre-requisite I will need in place to start this is a <strong>Priority Queue</strong>. This is a data structure that allows us to retrieve the minimum value, or maximum (depending on implementation), in the data set very efficiently. During the course of the path finding algorithm we will be pushing the path weights onto the queue and then retrieving the smallest one to determine the next step in the path.</p>\r\n\r\n<p>So, let's consider a set of values in an array:<br /></p>\r\n\r\n<p><img src=\"/artifacts/javascript-priority-queue/array.png\" class=\"array\" /></p>\r\n\r\n<p>Currently this array is a set of unordered values with a linear structure. However, it could also be thought of as a nearly complete binary tree:<br /></p>\r\n\r\n<p><img src=\"/artifacts/javascript-priority-queue/tree.png\" /></p>\r\n\r\n<p>Once we think of the structure in this way, we can begin to use tree properties and methods to manipulate the data.</p>\r\n\r\n<h2>Binary Heaps</h2>\r\n\r\n<p>The priority queue I am building is implemented on a Binary Heap data structure. Binary Heaps are complete, or nearly complete, binary trees with two additional properties.</p>\r\n\r\n<ul>\r\n<li><strong>Shape Property</strong> - The structure is a Binary Tree, or nearly complete Binary Tree. All levels must be fully filled, except possibly the last level. If that level is not filled it must be filled from left to right.</li>\r\n<li><strong>Heap Property</strong> - The nodes of the tree are either less than or equal to, or greater than or equal to, each of its children.</li>\r\n</ul>\r\n\r\n<p>Usually Binary Heaps are referred to as Min-Heaps or Max-Heaps depending on how the Heap Property is implemented. For the shortest path problems we will implement a Min-Heap for our Priority Queue.</p>\r\n\r\n<h3>Building the Heap</h3>\r\n\r\n<p>To start we take the items from FLOOR((A.length - 1) / 2) down to zero and apply our MinHeapify algorithm. The reason for this is that these items will all be nodes, while the remaining items will all be leaves.</p>\r\n\r\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Green;\">// Size is A.length - 1 to compensate for a zero indexed array.</span>\r\n<span style=\"color:Blue;\">function</span> buildMinHeap(A, size) {\r\n    <span style=\"color:Blue;\">for</span>(<span style=\"color:Blue;\">var</span> i = Math.floor(size / 2); i &gt;= 0; i--) { \r\n        minHeapify(A, i, size); \r\n    }\r\n}\r\n</pre></div>\r\n\r\n<p>Now that we have these items selected we will start applying our MinHeapify algorithm. We cycle through and determine if the current element at A[i], the left child, or the right child is the smallest. If the current element is already the smallest then the current sub-tree is a Min-Heap and we can go to the next node. If one of the children is the smallest we swap it with the root and we now have a sub-tree that is a Min-Heap.</p>\r\n\r\n<p>In the situation where we swap a child value for the current index value we could have sub-tree rooted at A[smallest] that no longer meets the <strong>Heap Property</strong>. Therefore we need to recursively apply the MinHeapify algorithm to that sub-tree to repeat the process.</p>\r\n\r\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">function</span> minHeapify(A, i, size) {\r\n    <span style=\"color:Blue;\">var</span> l = left(i);\r\n    <span style=\"color:Blue;\">var</span> r = right(i);\r\n    <span style=\"color:Blue;\">var</span> smallest;\r\n\r\n    <span style=\"color:Blue;\">if</span>(l &lt;= size &amp;&amp; A[l] &lt; A[i]) {\r\n        smallest = l; \r\n    } <span style=\"color:Blue;\">else</span> {\r\n        smallest = i; \r\n    }\r\n\r\n    <span style=\"color:Blue;\">if</span>(r &lt;= size &amp;&amp; A[r] &lt; A[smallest]) {\r\n        smallest = r; \r\n    }\r\n\r\n    <span style=\"color:Blue;\">if</span>(smallest != i) {\r\n        <span style=\"color:Blue;\">var</span> tmp = A[i];\r\n        A[i] = A[smallest];\r\n        A[smallest] = tmp;\r\n\r\n        minHeapify(A, smallest, size);\r\n    }\r\n}\r\n</pre></div>\r\n\r\n<p>We now have a Min-Heap structure that meets the <strong>Shape Property</strong> and the <strong>Heap Property</strong>. It's worth noting that it is not necessarily in lowest to highest order within the array itself.<br />\r\n<img src=\"/artifacts/javascript-priority-queue/minheap.png\" /></p>\r\n\r\n<h2>Priority Queue</h2>\r\n\r\n<p>Now that we have our Binary Heap structure implementing the Priority Queue is trivial.</p>\r\n\r\n<p>For our interface we will have four methods into the queue.</p>\r\n\r\n<ul>\r\n<li><strong>Peek</strong> will return the smallest value without removing it from the queue.</li>\r\n<li><strong>Pop</strong> will return the smallest value and remove it from the queue. This forces a reorganization of the nodes.</li>\r\n<li><strong>Push</strong> will insert a new value into the heap and organize it appropriately.</li>\r\n<li><strong>Print</strong> is a debugging function that will print out the array structure in order.</li>\r\n</ul>\r\n\r\n<h3>Peek</h3>\r\n\r\n<p>This is probably the simplest method in the whole structure. It simply returns the item at the zero index of the array.</p>\r\n\r\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">function</span> peek() {\r\n    <span style=\"color:Blue;\">if</span>(array.length &lt; 1) {\r\n        <span style=\"color:Blue;\">throw</span> <span style=\"color:#A31515;\">&#39;Heap Underflow&#39;</span>;\r\n    }\r\n\r\n    <span style=\"color:Blue;\">return</span> array[0];\r\n}\r\n</pre></div>\r\n\r\n<h3>Pop</h3>\r\n\r\n<p>This method is only slightly different from Peek. We return the minimum value from the array at index zero, but we also remove that item from the array. We then take the last item and move it to the front and run MinHeapify on the array to restructure it.</p>\r\n\r\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">function</span> pop() {\r\n    <span style=\"color:Blue;\">if</span>(array.length &lt; 1) {\r\n        <span style=\"color:Blue;\">throw</span> <span style=\"color:#A31515;\">&#39;Heap Underflow&#39;</span>;\r\n    }\r\n\r\n    <span style=\"color:Blue;\">var</span> min = array[0];\r\n    array[0] = array[array.length - 1];\r\n    array.splice(array.length - 1, 1);\r\n\r\n    minHeapify(array, 0, array.length - 1);\r\n\r\n    <span style=\"color:Blue;\">return</span> min;\r\n}\r\n</pre></div>\r\n\r\n<h3>Push</h3>\r\n\r\n<p>For push we add the new value to the end of the array bubble is up to its appropriate location. We assume that we are already working with a structure that meets the <strong>Heap Property</strong>.</p>\r\n\r\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">function</span> queue(value) {\r\n    array.push(value);\r\n    heapDecreaseKey(array, array.length - 1, value);\r\n}\r\n\r\n<span style=\"color:Blue;\">function</span> heapDecreaseKey(A, i, key) {\r\n    <span style=\"color:Blue;\">while</span>(i &gt; 0 &amp;&amp; A[parent(i)] &gt; A[i]) {\r\n        <span style=\"color:Blue;\">var</span> tmp = A[i];\r\n        A[i] = A[parent(i)];\r\n        A[parent(i)] = tmp;\r\n        i = parent(i);\r\n    }\r\n}\r\n</pre></div>\r\n\r\n<h3>Print</h3>\r\n\r\n<p>With print we just cycle through the array and log the current value.</p>\r\n\r\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">function</span> print() {\r\n    <span style=\"color:Blue;\">for</span>(<span style=\"color:Blue;\">var</span> i = 0; i &lt; array.length; i++) {\r\n        console.log(array[i]); \r\n    }\r\n}\r\n</pre></div>\r\n\r\n<h3>The Complete Code</h3>\r\n\r\n<p>That is it! We now have our Min-Priority Queue ready to go. The complete code looks like this:</p>\r\n\r\n<div style=\"color:Black;background-color:White;\"><pre>\r\napp_ns.MinPriorityQueue = (<span style=\"color:Blue;\">function</span>() {\r\n  <span style=\"color:Blue;\">var</span> array;\r\n\r\n  <span style=\"color:Blue;\">function</span> left(i) {\r\n    <span style=\"color:Blue;\">return</span> 2 * i + 1;\r\n  }\r\n\r\n  <span style=\"color:Blue;\">function</span> right(i) {\r\n    <span style=\"color:Blue;\">return</span> 2 * i + 2;\r\n  }\r\n\r\n  <span style=\"color:Blue;\">function</span> parent(i) {\r\n    <span style=\"color:Blue;\">return</span> Math.floor(i / 2); \r\n  }\r\n\r\n  <span style=\"color:Blue;\">function</span> minHeapify(A, i, size) {\r\n    <span style=\"color:Blue;\">var</span> l = left(i);\r\n    <span style=\"color:Blue;\">var</span> r = right(i);\r\n    <span style=\"color:Blue;\">var</span> largest;\r\n\r\n    <span style=\"color:Blue;\">if</span>(l &lt;= size &amp;&amp; A[l] &lt; A[i]) {\r\n     largest = l; \r\n    } <span style=\"color:Blue;\">else</span> {\r\n     largest = i; \r\n    }\r\n\r\n    <span style=\"color:Blue;\">if</span>(r &lt;= size &amp;&amp; A[r] &lt; A[largest]) {\r\n     largest = r; \r\n    }\r\n\r\n    <span style=\"color:Blue;\">if</span>(largest != i) {\r\n      <span style=\"color:Blue;\">var</span> tmp = A[i];\r\n      A[i] = A[largest];\r\n      A[largest] = tmp;\r\n\r\n      minHeapify(A, largest, size);\r\n    }\r\n  }\r\n\r\n  <span style=\"color:Blue;\">function</span> buildMinHeap(A, size) {\r\n    <span style=\"color:Blue;\">for</span>(<span style=\"color:Blue;\">var</span> i = Math.floor(size / 2); i &gt;= 0; i--) { \r\n     minHeapify(A, i, size); \r\n    }\r\n  }\r\n\r\n  <span style=\"color:Blue;\">function</span> peek() {\r\n    <span style=\"color:Blue;\">if</span>(array.length &lt; 1) {\r\n      <span style=\"color:Blue;\">throw</span> <span style=\"color:#A31515;\">&#39;Heap Underflow&#39;</span>;\r\n    }\r\n\r\n    <span style=\"color:Blue;\">return</span> array[0];\r\n  }\r\n\r\n  <span style=\"color:Blue;\">function</span> pop() {\r\n    <span style=\"color:Blue;\">if</span>(array.length &lt; 1) {\r\n      <span style=\"color:Blue;\">throw</span> <span style=\"color:#A31515;\">&#39;Heap Underflow&#39;</span>;\r\n    }\r\n\r\n    <span style=\"color:Blue;\">var</span> min = array[0];\r\n    array[0] = array[array.length - 1];\r\n    array.splice(array.length - 1, 1);\r\n\r\n    minHeapify(array, 0, array.length - 1);\r\n\r\n    <span style=\"color:Blue;\">return</span> min;\r\n  }\r\n\r\n  <span style=\"color:Blue;\">function</span> push(value) {\r\n    array.push(value);\r\n    heapDecreaseKey(array, array.length - 1, value);\r\n  }\r\n\r\n  <span style=\"color:Blue;\">function</span> print() {\r\n    <span style=\"color:Blue;\">for</span>(<span style=\"color:Blue;\">var</span> i = 0; i &lt; array.length; i++) {\r\n     console.log(array[i]); \r\n    }\r\n  }\r\n\r\n  <span style=\"color:Blue;\">function</span> heapDecreaseKey(A, i, key) {\r\n    <span style=\"color:Blue;\">while</span>(i &gt; 0 &amp;&amp; A[parent(i)] &gt; A[i]) {\r\n      <span style=\"color:Blue;\">var</span> tmp = A[i];\r\n      A[i] = A[parent(i)];\r\n      A[parent(i)] = tmp;\r\n      i = parent(i);\r\n    }\r\n  }\r\n\r\n\r\n\r\n  <span style=\"color:Blue;\">var</span> api = <span style=\"color:Blue;\">function</span>(arr) {\r\n    array = arr;\r\n    buildMinHeap(array, array.length -1);\r\n\r\n    <span style=\"color:Blue;\">this</span>.peek = peek;\r\n    <span style=\"color:Blue;\">this</span>.pop = pop;\r\n    <span style=\"color:Blue;\">this</span>.queue = queue;\r\n    <span style=\"color:Blue;\">this</span>.print = print;\r\n  };\r\n\r\n  <span style=\"color:Blue;\">return</span> api;\r\n\r\n})();\r\n</pre></div>\r\n\r\n<p>Using this structure is very simple. To create a queue and initialize it with values looks like this: </p>\r\n\r\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">var</span> minQueue = <span style=\"color:Blue;\">new</span> app_ns.MinPriorityQueue([11, 24, 22, 13, 9, 7, 8, 10, 14, 16]);\r\n</pre></div>\r\n\r\n<p>To push values onto the queue:</p>\r\n\r\n<div style=\"color:Black;background-color:White;\"><pre>\r\nminQueue.push(1);\r\n</pre></div>\r\n\r\n<p>And to pop values from the queue:</p>\r\n\r\n<div style=\"color:Black;background-color:White;\"><pre>\r\n<span style=\"color:Blue;\">var</span> value = minQueue.pop();\r\n</pre></div>\r\n","MarkdownContent":null,"Id":"a46ab900-5ef6-4291-9aa6-f97ecda7ee5f","PublishDate":"2014-01-28T00:00:00","Tags":[],"Title":"JavaScript Priority Queue","Comments":[],"ScriptDependencies":[],"SearchableContent":""}