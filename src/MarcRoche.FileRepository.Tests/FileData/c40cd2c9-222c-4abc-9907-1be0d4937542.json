{"Author":"","Content":"<div>\r\n  <p>In this article I am going to review Expression Tree fundamentals. Expression Trees can best be thought of as code that is stored like data and can be executed at some later time (a concept that is quite important in functional languages).</p>\r\n  <p>Consider the following Expression:</p>\r\n  <pre><![CDATA[\r\nExpression&lt;Func&lt;int, int, int&gt;&gt; add = (a, b) =&gt; a + b;\r\n]]></pre>\r\n  <p>We store a function that takes two integer parameters and returns the sum.</p>\r\n  <p>To demonstrate letï¿½s take this Expression and compile and execute it with two values result:</p>\r\n  <pre><![CDATA[\r\nstatic void Main(string[] args)\r\n{\r\n\t//Our Basic Expression\r\n\tExpression&lt;Func&lt;int, int, int&gt;&gt; add = (a, b) =&gt; a + b;\r\n\r\n  bool result = add.Compile()(10, 20);\r\n  Console.WriteLine(\"10 + 20 = \" + result.ToString());\r\n\r\n  Console.ReadKey();\r\n}\r\n\t  ]]></pre>\r\n  <p>Simple enough. On <em>line 6</em> we say:</p>\r\n  <pre><![CDATA[\r\nbool result = add.Compile()(10, 20);\r\n]]></pre>\r\n  <p>which compiles the Expression to executable code and executes it with 10 and 20 as parameters. This returns 30 as the result.</p>\r\n  <p>However when we examine the Expression Tree that is generated under the hood things become a little more involved. To demonstrate how the tree is structured we construct it manually in the next example:</p>\r\n  <pre><![CDATA[\r\nstatic void Main(string[] args)\r\n{\r\n//The Parameters passed into the function (a, b)\r\nParameterExpression p1 = Expression.Parameter(typeof(int), \"a\");\r\nParameterExpression p2 = Expression.Parameter(typeof(int), \"b\");\r\n\r\n//Now the function itself\r\n//On the left side of the boolean operation we add the two parameters\r\nBinaryExpression addParams = Expression.Add(p1, p2);\r\n\r\n//On the right side of the boolean operation we just have a constant\r\nConstantExpression thirtyConst = Expression.Constant(30);\r\n\r\n//Now we store the boolean operation of the params and the constant\r\nBinaryExpression booleanOp = Expression.Equal(addParams, thirtyConst);\r\n\r\n//Finally the complete lambda that takes the parameters and\r\n//performs the boolean operation we defined\r\nLambdaExpression le = Expression.Lambda(booleanOp, p1, p2);\r\n\r\n//Now to confirm\r\nbool result = (bool)le.Compile().DynamicInvoke(10, 20);\r\nConsole.WriteLine(\"10 + 20 = \" + result.ToString());\r\n\r\nConsole.ReadKey();\r\n}\r\n]]></pre>\r\n  <p>So let's break this down.</p>\r\n  <p>We first create each parameter as a ParameterExpression of type int.</p>\r\n  <p>Then we move onto the body of the function.</p>\r\n  <p>For the left side we create a BinaryExpression to represent the addition of the two parameters. For the right side we create a ConstantExpression to represent the 30. To complete the function body we create the BinaryExpression to represent the boolean evaluation of the two sides.</p>\r\n  <p>Finally we add the parameters and method body into the LambdaExpression that represents the entire declaration.</p>\r\n  <p>Now we compile and execute again with <em>line 22</em>:</p>\r\n  <pre><![CDATA[\r\nbool result = (bool)le.Compile().DynamicInvoke(10, 20);\r\n]]></pre>\r\n  <p>and confirm the same result.</p>\r\n  <p>Whew! This seems like a lot of work when we could just use the code from first example, Right?! In a real world application, such as a custom linq provider, this level of control would allow you translate the tree into other forms of executable code.</p>\r\n  <p>For an excellent resource on creating a custom Linq Provider <a href=\"http://msdn.microsoft.com/en-us/library/bb546158.aspx\" target=\"_blank\">view this MSDN article</a>.</p>\r\n  <p>Stay tuned! In the following posts we will begin to dive into some of the more interesting aspects of Expressions and the Dynamic Language Runtime (aka DLR)!</p>\r\n</div>","Id":"c40cd2c9-222c-4abc-9907-1be0d4937542","PublishDate":"2012-05-15T00:00:00","Tags":null,"Title":"Expression Tree Fundamentals","Comments":[],"SearchableContent":""}