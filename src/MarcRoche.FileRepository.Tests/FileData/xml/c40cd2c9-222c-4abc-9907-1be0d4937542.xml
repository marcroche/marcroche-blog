<BlogPost title="Expression Tree Fundamentals" publishdate="5/15/2012 12:00:00 AM" id="c40cd2c9-222c-4abc-9907-1be0d4937542" author="">
  <Content>
    <div>
      <p>In this article I am going to review Expression Tree fundamentals. Expression Trees can best be thought of as code that is stored like data and can be executed at some later time (a concept that is quite important in functional languages).</p>
      <p>Consider the following Expression:</p>
      <pre><![CDATA[
Expression&lt;Func&lt;int, int, int&gt;&gt; add = (a, b) =&gt; a + b;
]]></pre>
      <p>We store a function that takes two integer parameters and returns the sum.</p>
      <p>To demonstrate letï¿½s take this Expression and compile and execute it with two values result:</p>
      <pre><![CDATA[
static void Main(string[] args)
{
	//Our Basic Expression
	Expression&lt;Func&lt;int, int, int&gt;&gt; add = (a, b) =&gt; a + b;

  bool result = add.Compile()(10, 20);
  Console.WriteLine("10 + 20 = " + result.ToString());

  Console.ReadKey();
}
	  ]]></pre>
      <p>Simple enough. On <em>line 6</em> we say:</p>
      <pre><![CDATA[
bool result = add.Compile()(10, 20);
]]></pre>
      <p>which compiles the Expression to executable code and executes it with 10 and 20 as parameters. This returns 30 as the result.</p>
      <p>However when we examine the Expression Tree that is generated under the hood things become a little more involved. To demonstrate how the tree is structured we construct it manually in the next example:</p>
      <pre><![CDATA[
static void Main(string[] args)
{
//The Parameters passed into the function (a, b)
ParameterExpression p1 = Expression.Parameter(typeof(int), "a");
ParameterExpression p2 = Expression.Parameter(typeof(int), "b");

//Now the function itself
//On the left side of the boolean operation we add the two parameters
BinaryExpression addParams = Expression.Add(p1, p2);

//On the right side of the boolean operation we just have a constant
ConstantExpression thirtyConst = Expression.Constant(30);

//Now we store the boolean operation of the params and the constant
BinaryExpression booleanOp = Expression.Equal(addParams, thirtyConst);

//Finally the complete lambda that takes the parameters and
//performs the boolean operation we defined
LambdaExpression le = Expression.Lambda(booleanOp, p1, p2);

//Now to confirm
bool result = (bool)le.Compile().DynamicInvoke(10, 20);
Console.WriteLine("10 + 20 = " + result.ToString());

Console.ReadKey();
}
]]></pre>
      <p>So let's break this down.</p>
      <p>We first create each parameter as a ParameterExpression of type int.</p>
      <p>Then we move onto the body of the function.</p>
      <p>For the left side we create a BinaryExpression to represent the addition of the two parameters. For the right side we create a ConstantExpression to represent the 30. To complete the function body we create the BinaryExpression to represent the boolean evaluation of the two sides.</p>
      <p>Finally we add the parameters and method body into the LambdaExpression that represents the entire declaration.</p>
      <p>Now we compile and execute again with <em>line 22</em>:</p>
      <pre><![CDATA[
bool result = (bool)le.Compile().DynamicInvoke(10, 20);
]]></pre>
      <p>and confirm the same result.</p>
      <p>Whew! This seems like a lot of work when we could just use the code from first example, Right?! In a real world application, such as a custom linq provider, this level of control would allow you translate the tree into other forms of executable code.</p>
      <p>For an excellent resource on creating a custom Linq Provider <a href="http://msdn.microsoft.com/en-us/library/bb546158.aspx" target="_blank">view this MSDN article</a>.</p>
      <p>Stay tuned! In the following posts we will begin to dive into some of the more interesting aspects of Expressions and the Dynamic Language Runtime (aka DLR)!</p>
    </div>
  </Content>
</BlogPost>