<BlogPost title="Expression Trees and the Dynamic Language Runtime" publishdate="6/6/2012 12:00:00 AM" id="6efdcf97-2151-41a9-b65e-f7e3ceb24db2" author="">
  <Content>
    <div>
      <p>Continuing with the theme started in Expression Tree Fundamentals we dive a little deeper into how Expression Trees behave in .Net 4.0.</p>
      <p>One of the areas I want to explore is the ability to generate code at runtime. Prior to .Net 4.0 you had to rely on options like Reflection.Emit to dynamically generate code, and this was no pleasurable chore.</p>
      <p>Consider a simple example that takes two integer parameters and adds them together then returns the result:</p>
      <pre><![CDATA[
public static int Add(int value1, int value2)
{
	return value1 + value2;
}
]]></pre>
      <p>To dynamically generate this code using Reflection.Emit you would end up with something like this:</p>
      <pre><![CDATA[
static void Main()
{
	// Define our method that takes two ints as parameters
	// and returns an int as the result
	DynamicMethod add = new DynamicMethod(
		"Add",
		typeof(int),
		new Type[] { typeof(int), typeof(int) },
		typeof(int).Module);

	// Get an IL Code Generator
	ILGenerator ILGenerator = add.GetILGenerator();

	// local variables in the method
	LocalBuilder value1 = ILGenerator.DeclareLocal(typeof(int));
	LocalBuilder value2 = ILGenerator.DeclareLocal(typeof(int));

	// Store the parameters in our local variables
	ILGenerator.Emit(OpCodes.Ldarg_0);
	ILGenerator.Emit(OpCodes.Stloc, value1);

	ILGenerator.Emit(OpCodes.Ldarg_1);
	ILGenerator.Emit(OpCodes.Stloc, value2);

	// Add our local variables
	ILGenerator.Emit(OpCodes.Ldloc, value1);
	ILGenerator.Emit(OpCodes.Ldloc, value2);
	ILGenerator.Emit(OpCodes.Add);

	// Return
	ILGenerator.Emit(OpCodes.Ret);

	// Execute and observe the result
	Console.WriteLine(add.Invoke(null, new object[] { 8, 4 }));
	Console.ReadKey();
}
]]></pre>
      <p>In this example the DynamicMethod defines the method and will dynamically generate the MSIL needed. It's not an extremely intuitive approach and the code can become quite difficult to wade through.</p>
      <p>There is good news though! Expression Trees have brought a new approach to generating code dynamically. In .Net 4.0 we have to abillity to generate complex code structures with Expressions.</p>
      <p>Take the following example where we re-create the sample code in a more elegant and intuitive fashion:</p>
      <pre><![CDATA[
static void Main()
{
	// Create the method paramaters
	ParameterExpression value1 = Expression.Parameter(typeof(int), &quot;value1&quot;);
	ParameterExpression value2 = Expression.Parameter(typeof(int), &quot;value2&quot;);

	// Define the method
	Expression&lt;Func&lt;int, int, int&gt;&gt; lambda = Expression.Lambda&lt;Func&lt;int, int, int&gt;&gt;(
		Expression.Add(value1, value2), 
		&quot;Add&quot;,
		new ParameterExpression[] { value1, value2 }); 

	// Compile, Execute and display the result
	Console.WriteLine(lambda.Compile()(8, 4));
	Console.ReadKey();
}
]]></pre>
      <p>And here we can validate that we have generated a method that returns the same result as the previous example!</p>
      <p>Obviously just writing the code as a method is the simplest. However there may be times when you want to generate code at runtime. Using Expression Trees provides a functional and intuitive interface for this task.</p>
    </div>
  </Content>
</BlogPost>