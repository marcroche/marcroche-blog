{"Author":"","Content":"<div>\r\n  <p>Continuing with the theme started in Expression Tree Fundamentals we dive a little deeper into how Expression Trees behave in .Net 4.0.</p>\r\n  <p>One of the areas I want to explore is the ability to generate code at runtime. Prior to .Net 4.0 you had to rely on options like Reflection.Emit to dynamically generate code, and this was no pleasurable chore.</p>\r\n  <p>Consider a simple example that takes two integer parameters and adds them together then returns the result:</p>\r\n  <pre><![CDATA[\r\npublic static int Add(int value1, int value2)\r\n{\r\n\treturn value1 + value2;\r\n}\r\n]]></pre>\r\n  <p>To dynamically generate this code using Reflection.Emit you would end up with something like this:</p>\r\n  <pre><![CDATA[\r\nstatic void Main()\r\n{\r\n\t// Define our method that takes two ints as parameters\r\n\t// and returns an int as the result\r\n\tDynamicMethod add = new DynamicMethod(\r\n\t\t\"Add\",\r\n\t\ttypeof(int),\r\n\t\tnew Type[] { typeof(int), typeof(int) },\r\n\t\ttypeof(int).Module);\r\n\r\n\t// Get an IL Code Generator\r\n\tILGenerator ILGenerator = add.GetILGenerator();\r\n\r\n\t// local variables in the method\r\n\tLocalBuilder value1 = ILGenerator.DeclareLocal(typeof(int));\r\n\tLocalBuilder value2 = ILGenerator.DeclareLocal(typeof(int));\r\n\r\n\t// Store the parameters in our local variables\r\n\tILGenerator.Emit(OpCodes.Ldarg_0);\r\n\tILGenerator.Emit(OpCodes.Stloc, value1);\r\n\r\n\tILGenerator.Emit(OpCodes.Ldarg_1);\r\n\tILGenerator.Emit(OpCodes.Stloc, value2);\r\n\r\n\t// Add our local variables\r\n\tILGenerator.Emit(OpCodes.Ldloc, value1);\r\n\tILGenerator.Emit(OpCodes.Ldloc, value2);\r\n\tILGenerator.Emit(OpCodes.Add);\r\n\r\n\t// Return\r\n\tILGenerator.Emit(OpCodes.Ret);\r\n\r\n\t// Execute and observe the result\r\n\tConsole.WriteLine(add.Invoke(null, new object[] { 8, 4 }));\r\n\tConsole.ReadKey();\r\n}\r\n]]></pre>\r\n  <p>In this example the DynamicMethod defines the method and will dynamically generate the MSIL needed. It's not an extremely intuitive approach and the code can become quite difficult to wade through.</p>\r\n  <p>There is good news though! Expression Trees have brought a new approach to generating code dynamically. In .Net 4.0 we have to abillity to generate complex code structures with Expressions.</p>\r\n  <p>Take the following example where we re-create the sample code in a more elegant and intuitive fashion:</p>\r\n  <pre><![CDATA[\r\nstatic void Main()\r\n{\r\n\t// Create the method paramaters\r\n\tParameterExpression value1 = Expression.Parameter(typeof(int), &quot;value1&quot;);\r\n\tParameterExpression value2 = Expression.Parameter(typeof(int), &quot;value2&quot;);\r\n\r\n\t// Define the method\r\n\tExpression&lt;Func&lt;int, int, int&gt;&gt; lambda = Expression.Lambda&lt;Func&lt;int, int, int&gt;&gt;(\r\n\t\tExpression.Add(value1, value2), \r\n\t\t&quot;Add&quot;,\r\n\t\tnew ParameterExpression[] { value1, value2 }); \r\n\r\n\t// Compile, Execute and display the result\r\n\tConsole.WriteLine(lambda.Compile()(8, 4));\r\n\tConsole.ReadKey();\r\n}\r\n]]></pre>\r\n  <p>And here we can validate that we have generated a method that returns the same result as the previous example!</p>\r\n  <p>Obviously just writing the code as a method is the simplest. However there may be times when you want to generate code at runtime. Using Expression Trees provides a functional and intuitive interface for this task.</p>\r\n</div>","Id":"6efdcf97-2151-41a9-b65e-f7e3ceb24db2","PublishDate":"2012-06-06T00:00:00","Tags":null,"Title":"Expression Trees and the Dynamic Language Runtime","Comments":[],"SearchableContent":""}